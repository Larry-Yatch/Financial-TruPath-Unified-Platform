<script>
/**
 * Universal Tool Wrapper for Financial TruPath Platform
 * Supports 4 tool patterns across 8 tools
 * Pattern 1: Insights Assessment (Tool 1)
 * Pattern 2: Comprehensive Assessment (Tool 2)
 * Pattern 3: Grounding Templates (Tools 3, 5, 7)
 * Pattern 4: Interactive Calculators (Tools 4, 6, 8)
 */

const ToolWrapper = {
  // Current tool state
  currentTool: null,
  currentPattern: null,
  autoSaveTimer: null,
  lastSaveTime: null,
  savingInProgress: false,
  
  // Tool configurations by pattern
  patterns: {
    'pattern1': { // Tool 1: Orientation
      hasForm: true,
      hasSections: true,
      sectionCount: 5,
      canSaveDraft: true,
      hasReport: true,
      navigation: ['load', 'dashboard', 'help', 'logout'], // Removed 'save' from landing - only show on form
      autoSaveInterval: 120000 // 2 minutes
    },
    'pattern2': { // Tool 2: Financial Clarity
      hasForm: true,
      hasSections: true,
      sectionCount: 7,
      canSaveDraft: true,
      hasReport: true,
      isAdaptive: true,
      navigation: ['save', 'load', 'dashboard', 'help', 'insights'], // Removed 'print'
      autoSaveInterval: 120000
    },
    'pattern3': { // Tools 3, 5, 7: Grounding
      hasForm: true,
      hasSections: false,
      canSaveDraft: true,
      hasReport: true,
      navigation: ['save', 'load', 'dashboard', 'help'], // Removed 'print'
      autoSaveInterval: 180000 // 3 minutes
    },
    'pattern4': { // Tools 4, 6, 8: Calculators
      hasForm: false,
      hasSections: false,
      canSaveDraft: true,
      hasReport: false,
      hasExport: true,
      navigation: ['save', 'load', 'dashboard', 'export', 'help'],
      autoSaveInterval: 60000 // 1 minute for live calculators
    }
  },
  
  // Tool metadata
  tools: {
    'test': {
      pattern: 'pattern1',
      title: 'Foundation Test Tool',
      icon: 'üß™',
      description: 'Test the V10 foundation framework',
      estimatedTime: '5 minutes'
    },
    'tool1': {
      pattern: 'pattern1',
      title: 'Orientation Assessment',
      icon: 'üí°',
      description: 'Discover your Financial GPS',
      estimatedTime: '20 minutes'
    },
    'tool2': {
      pattern: 'pattern2',
      title: 'Financial Clarity',
      icon: 'üí∞',
      description: 'Deep dive into your financial situation',
      estimatedTime: '30 minutes'
    },
    'tool3': {
      pattern: 'pattern3',
      title: 'Control Fear Grounding',
      icon: 'üßò',
      description: 'Understand your emotional money patterns',
      estimatedTime: '15 minutes'
    },
    'tool4': {
      pattern: 'pattern4',
      title: 'Goal Setting Framework',
      icon: 'üéØ',
      description: 'Build SMART financial goals',
      estimatedTime: '25 minutes'
    },
    'tool5': {
      pattern: 'pattern3',
      title: 'Investment Strategy',
      icon: 'üìà',
      description: 'Discover your investment personality',
      estimatedTime: '20 minutes'
    },
    'tool6': {
      pattern: 'pattern4',
      title: 'Debt Management',
      icon: 'üí≥',
      description: 'Optimize your debt reduction strategy',
      estimatedTime: '15 minutes'
    },
    'tool7': {
      pattern: 'pattern3',
      title: 'Retirement Blueprint',
      icon: 'üèñÔ∏è',
      description: 'Plan your retirement journey',
      estimatedTime: '25 minutes'
    },
    'tool8': {
      pattern: 'pattern4',
      title: 'Financial Dashboard',
      icon: 'üìä',
      description: 'Track your complete financial picture',
      estimatedTime: '10 minutes'
    }
  },
  
  /**
   * Initialize wrapper for any tool
   * @param {string} toolId - Tool identifier (tool1-tool8)
   * @returns {string} HTML for wrapper
   */
  init(toolId) {
    const tool = this.tools[toolId];
    if (!tool) {
      console.error(`Unknown tool: ${toolId}`);
      return '';
    }
    
    const pattern = tool.pattern;
    const config = this.patterns[pattern];
    
    this.currentTool = toolId;
    this.currentPattern = pattern;
    
    // Build wrapper HTML
    const wrapperHtml = `
      <div id="tool-wrapper" data-tool="${toolId}" data-pattern="${pattern}" class="tool-wrapper">
        ${this.renderNavigation(config.navigation, toolId)}
        ${this.renderHeader(tool)}
        ${config.hasSections ? this.renderProgress(toolId, config.sectionCount) : ''}
        <div id="tool-content" class="tool-content-area">
          <!-- Tool-specific content loads here -->
        </div>
      </div>
    `;
    
    // Set up auto-save only after form is loaded, not on landing page
    setTimeout(() => {
      this.checkForExistingDraft(toolId);
      // Don't start autosave until form is actually shown
    }, 100);
    
    return wrapperHtml;
  },
  
  /**
   * Render navigation bar based on tool needs
   */
  renderNavigation(navItems, toolId) {
    const buttons = {
      save: `<button onclick="ToolWrapper.saveDraft()" class="btn-nav" title="Save your progress">
               <span class="nav-icon">üíæ</span>
               <span class="nav-text">Save</span>
             </button>`,
      load: `<button onclick="ToolWrapper.showLoadOptions()" class="btn-nav" title="Load previous work">
               <span class="nav-icon">üìÇ</span>
               <span class="nav-text">Load</span>
             </button>`,
      dashboard: `<button onclick="ToolWrapper.backToDashboard()" class="btn-nav" title="Return to dashboard">
                    <span class="nav-icon">üè†</span>
                    <span class="nav-text">Dashboard</span>
                  </button>`,
      print: `<button onclick="ToolWrapper.printTool()" class="btn-nav" title="Print this page">
                <span class="nav-icon">üñ®Ô∏è</span>
                <span class="nav-text">Print</span>
              </button>`,
      export: `<button onclick="ToolWrapper.exportData()" class="btn-nav" title="Export your data">
                 <span class="nav-icon">üìä</span>
                 <span class="nav-text">Export</span>
               </button>`,
      logout: `<button onclick="ToolWrapper.logout()" class="btn-nav" title="Sign out">
                 <span class="nav-icon">üö™</span>
                 <span class="nav-text">Logout</span>
               </button>`,
      help: `<button onclick="ToolWrapper.showHelp()" class="btn-nav" title="Get help">
               <span class="nav-icon">‚ùì</span>
               <span class="nav-text">Help</span>
             </button>`,
      insights: `<button onclick="ToolWrapper.showInsights()" class="btn-nav" title="View insights from other tools">
                   <span class="nav-icon">üí°</span>
                   <span class="nav-text">Insights</span>
                 </button>`
    };
    
    return `
      <nav class="tool-navigation">
        <div class="nav-left">
          ${navItems.slice(0, 3).map(item => buttons[item] || '').join('')}
        </div>
        <div class="nav-center">
          <div class="auto-save-indicator" id="auto-save-status" style="display: none;">
            <span class="save-dot" id="save-dot"></span>
            <span class="save-text" id="save-text">Auto-save: On</span>
          </div>
        </div>
        <div class="nav-right">
          ${navItems.slice(3).map(item => buttons[item] || '').join('')}
        </div>
      </nav>
    `;
  },
  
  /**
   * Render tool header with metadata
   */
  renderHeader(tool) {
    return `
      <div class="tool-header">
        <div class="tool-title">
          <span class="tool-icon">${tool.icon}</span>
          <h1>${tool.title}</h1>
        </div>
        <div class="tool-meta">
          <span class="tool-description">${tool.description}</span>
          <span class="tool-time">‚è±Ô∏è ${tool.estimatedTime}</span>
        </div>
      </div>
    `;
  },
  
  /**
   * Render progress bar for multi-section tools
   */
  renderProgress(toolId, sectionCount) {
    // Check if this tool provides its own progress bar
    // Tool 1 (index.html) has its own progress implementation
    const toolsWithOwnProgress = ['tool1', 'index'];
    
    if (toolsWithOwnProgress.includes(toolId)) {
      // Tool has its own progress bar, don't render ToolWrapper's
      console.log(`Tool ${toolId} has its own progress bar, skipping ToolWrapper progress`);
      return '';
    }
    
    return `
      <div class="progress-container" id="progress-${toolId}">
        <div class="progress-bar">
          <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
        </div>
        <div class="progress-text">
          <span id="progress-section">Getting Started</span>
          <span class="progress-separator">‚Ä¢</span>
          <span id="progress-percent">0% Complete</span>
          <span class="progress-separator">‚Ä¢</span>
          <span id="progress-steps">Section 1 of ${sectionCount}</span>
        </div>
      </div>
    `;
  },
  
  /**
   * Save current tool state as draft
   */
  saveDraft(isAutoSave = false) {
    if (!this.currentTool) return;
    
    // Prevent concurrent saves
    if (this.savingInProgress) {
      console.log('Save already in progress, skipping...');
      return;
    }
    
    this.savingInProgress = true;
    
    const toolId = this.currentTool;
    const pattern = this.currentPattern || 'pattern1'; // Default to pattern1 if not set
    const data = this.collectToolData(pattern);
    const progress = this.calculateProgress(pattern);
    
    // Check if form has any meaningful data before saving
    const hasData = this.hasFormData(data);
    if (!hasData && isAutoSave) {
      console.log('Skipping autosave - no form data entered yet');
      this.savingInProgress = false;
      return;
    }
    
    // Create draft object with all the data
    const draft = {
      toolId,
      pattern,
      data,
      progress,
      timestamp: new Date().toISOString(),
      isAutoSave
    };
    
    // Save to localStorage immediately (with safety check)
    const currentUserId = typeof userId !== 'undefined' ? userId : 'default';
    const localKey = `draft_${toolId}_${currentUserId}`;
    
    try {
      if (typeof Storage !== 'undefined') {
        localStorage.setItem(localKey, JSON.stringify(draft));
      }
    } catch (e) {
      console.warn('localStorage not available:', e);
    }
    
    // Update UI
    this.updateSaveIndicator('saving');
    
    // Save to Google Sheets if online
    if (typeof google !== 'undefined' && google.script && google.script.run) {
      // Log what we're saving for debugging
      console.log('Saving draft to cloud:', {
        userId: currentUserId,
        toolId,
        draftSize: JSON.stringify(draft).length,
        hasData: Object.keys(data).length > 0
      });
      
      google.script.run
        .withSuccessHandler(() => {
          this.updateSaveIndicator('saved');
          this.lastSaveTime = new Date();
          this.savingInProgress = false;  // Reset flag
          if (!isAutoSave) {
            this.showNotification('Progress saved successfully!', 'success');
          }
        })
        .withFailureHandler((error) => {
          console.error('Save to server failed:', error);
          this.updateSaveIndicator('local');
          this.savingInProgress = false;  // Reset flag
          if (!isAutoSave) {
            this.showNotification('Saved locally (offline mode)', 'warning');
          }
        })
        .saveToolDraft(currentUserId, toolId, data, progress, 'DRAFT', isAutoSave ? 'AUTO' : 'MANUAL');
      
      // Debug logging
      console.log('üêõ SAVE DEBUG:', {
        isAutoSave: isAutoSave,
        saveType: isAutoSave ? 'AUTO' : 'MANUAL',
        userId: currentUserId,
        toolId: toolId,
        progress: progress
      });
    } else {
      // Offline mode
      this.updateSaveIndicator('local');
      this.savingInProgress = false;  // Reset flag
      if (!isAutoSave) {
        this.showNotification('Progress saved locally', 'info');
      }
    }
  },
  
  /**
   * Collect data based on pattern type
   */
  collectToolData(pattern) {
    const config = this.patterns[pattern];
    
    if (config && config.hasForm) {
      // Form-based tools (Patterns 1, 2, 3)
      // First try to find form with standardized ID
      const form = document.getElementById('tool-form');
      if (form) {
        // Use FormData for proper form serialization
        const formData = new FormData(form);
        const data = {};
        
        // Convert FormData to plain object
        for (let [key, value] of formData.entries()) {
          // Handle multiple values for same name (like checkboxes)
          if (data[key]) {
            if (Array.isArray(data[key])) {
              data[key].push(value);
            } else {
              data[key] = [data[key], value];
            }
          } else {
            data[key] = value;
          }
        }
        
        // Also collect unchecked checkboxes and radios for completeness
        const inputs = form.querySelectorAll('input[type="checkbox"], input[type="radio"]');
        inputs.forEach(input => {
          if (!input.checked && input.name && !data[input.name]) {
            // Store false for unchecked checkboxes
            if (input.type === 'checkbox') {
              data[input.name] = false;
            }
            // Radio buttons: if none selected, the key won't exist (which is correct)
          }
        });
        
        console.log('Collected form data:', data);
        return data;
      }
      
      // Fallback to manual collection if no standard form found
      const data = {};
      const inputs = document.querySelectorAll('#tool-content input, #tool-content select, #tool-content textarea');
      
      inputs.forEach(field => {
        if (field.name) {
          if (field.type === 'checkbox') {
            // Store boolean for checkboxes
            data[field.name] = field.checked;
          } else if (field.type === 'radio') {
            // For radio buttons, only store if checked
            if (field.checked) {
              data[field.name] = field.value;
            }
          } else {
            // For all other input types, always store (even if empty)
            data[field.name] = field.value || '';
          }
        }
      });
      
      console.log('Collected fallback data:', data);
      return data;
    } else if (config) {
      // Calculator tools (Pattern 4) - collect state
      return this.getCalculatorState();
    }
    
    return {};
  },
  
  /**
   * Calculate progress for current tool
   */
  calculateProgress(pattern) {
    // SIMPLIFIED - just count filled fields
    const inputs = document.querySelectorAll('input:not([type="button"]):not([type="submit"]):not([type="hidden"]), select, textarea');
    let totalFields = 0;
    let filledFields = 0;
    
    inputs.forEach(field => {
      if (field.name) {  // Only count named fields
        totalFields++;
        if (field.type === 'checkbox' || field.type === 'radio') {
          if (field.checked) filledFields++;
        } else if (field.value && field.value.trim() !== '') {
          filledFields++;
        }
      }
    });
    
    const percentage = totalFields > 0 ? Math.round((filledFields / totalFields) * 100) : 0;
    
    return {
      percentage: percentage,
      completed: filledFields,
      total: totalFields
    };
  },
  
  /**
   * Load draft data
   */
  loadDraft(draftData = null) {
    if (!this.currentTool) return;
    
    const toolId = this.currentTool;
    const localKey = `draft_${toolId}_${typeof userId !== 'undefined' ? userId : 'default'}`;
    
    // Use provided draft or load from localStorage
    if (!draftData) {
      const localDraft = (typeof localStorage !== 'undefined' && localStorage) ? localStorage.getItem(localKey) : null;
      if (localDraft) {
        draftData = JSON.parse(localDraft);
      }
    }
    
    if (draftData && draftData.data) {
      this.restoreToolState(draftData);
      this.showNotification('Previous progress loaded', 'success');
    } else {
      this.showNotification('No saved progress found', 'info');
    }
  },
  
  /**
   * Restore tool state from draft
   */
  restoreToolState(draft) {
    // FIXED: Handle the actual data structure from saveDraft
    let dataToRestore = {};
    
    // The draft structure from saveDraft is: { toolId, pattern, data, progress, timestamp }
    // where data is the flat object from collectToolData()
    if (draft && draft.data && typeof draft.data === 'object') {
      dataToRestore = draft.data;
    } else if (draft && !draft.data) {
      // If draft IS the data itself (shouldn't happen but safety check)
      dataToRestore = draft;
    }
    
    console.log('Restoring draft data:', dataToRestore);
    
    // Restore all form fields
    const allInputs = document.querySelectorAll('input, select, textarea');
    let restoredCount = 0;
    
    allInputs.forEach(field => {
      const fieldName = field.name;
      if (fieldName && dataToRestore[fieldName] !== undefined) {
        if (field.type === 'checkbox') {
          field.checked = dataToRestore[fieldName] === 'on' || dataToRestore[fieldName] === true || dataToRestore[fieldName] === field.value;
          restoredCount++;
        } else if (field.type === 'radio') {
          field.checked = dataToRestore[fieldName] === field.value;
          if (field.checked) restoredCount++;
        } else {
          field.value = dataToRestore[fieldName];
          restoredCount++;
        }
      }
    });
    
    // Update progress if it exists
    if (draft.progress) {
      this.updateProgressDisplay(draft.progress);
    }
    
    this.showNotification(`Draft loaded (${restoredCount} fields restored)`, 'success');
  },
  
  /**
   * Check for existing drafts on tool load
   */
  checkForExistingDraft(toolId) {
    const localKey = `draft_${toolId}_${typeof userId !== 'undefined' ? userId : 'default'}`;
    const localDraft = (typeof localStorage !== 'undefined' && localStorage) ? localStorage.getItem(localKey) : null;
    
    if (localDraft) {
      const draft = JSON.parse(localDraft);
      const draftAge = new Date() - new Date(draft.timestamp);
      const hoursOld = Math.floor(draftAge / (1000 * 60 * 60));
      
      // FIXED: Use the actual progress from the saved draft
      let progressValue = 0;
      if (draft.progress) {
        progressValue = typeof draft.progress === 'object' ? draft.progress.percentage : draft.progress;
      }
      
      // Show continue button if draft exists
      const continueBtn = document.getElementById('continue-draft-btn');
      if (continueBtn) {
        continueBtn.style.display = 'block';
        continueBtn.innerHTML = `üìÇ Continue Previous (${progressValue}% complete, ${hoursOld}h ago)`;
        
        // Store draft for loading when clicked
        continueBtn.onclick = () => {
          this.restoreToolState(draft);
        };
      }
    }
    
    // Also check server for drafts
    if (typeof google !== 'undefined' && google.script && google.script.run) {
      google.script.run
        .withSuccessHandler((serverDraft) => {
          if (serverDraft && serverDraft.data) {
            // Server draft exists - compare with local
            if (!localDraft || new Date(serverDraft.timestamp) > new Date(JSON.parse(localDraft).timestamp)) {
              // Server draft is newer
              const continueBtn = document.getElementById('continue-draft-btn');
              if (continueBtn) {
                continueBtn.style.display = 'block';
                let serverProgress = 0;
                if (serverDraft.progress) {
                  serverProgress = typeof serverDraft.progress === 'object' ? serverDraft.progress.percentage : serverDraft.progress;
                }
                continueBtn.innerHTML = `üìÇ Continue Previous (${serverProgress}% complete - from cloud)`;
                
                // Store server draft for loading when clicked
                continueBtn.onclick = () => {
                  this.restoreToolState(serverDraft);
                };
              }
            }
          }
        })
        .getToolDraft(userId, toolId, false);
    }
  },
  
  /**
   * Initialize auto-save functionality
   */
  initAutoSave(interval = 120000) {
    // Clear any existing timer
    if (this.autoSaveTimer) {
      clearInterval(this.autoSaveTimer);
    }
    
    // Clean up on page unload
    window.addEventListener('beforeunload', () => {
      if (this.autoSaveTimer) {
        clearInterval(this.autoSaveTimer);
      }
      // Try to save one last time
      this.saveDraft(true);
    });
    
    // Debounced save on input changes
    let saveTimeout;
    document.addEventListener('input', (e) => {
      if (e.target.closest('#tool-content')) {
        clearTimeout(saveTimeout);
        this.updateSaveIndicator('pending');
        saveTimeout = setTimeout(() => {
          this.saveDraft(true);
        }, 10000); // 10 second debounce (reduced frequency)
      }
    });
    
    // Regular interval save
    this.autoSaveTimer = setInterval(() => {
      this.saveDraft(true);
    }, interval);
  },
  
  /**
   * Update save indicator UI
   */
  updateSaveIndicator(status) {
    const dot = document.getElementById('save-dot');
    const text = document.getElementById('save-text');
    
    if (!dot || !text) return;
    
    switch(status) {
      case 'saving':
        dot.className = 'save-dot saving';
        text.textContent = 'Saving...';
        break;
      case 'saved':
        dot.className = 'save-dot saved';
        text.textContent = 'Saved';
        setTimeout(() => {
          text.textContent = 'Auto-save: On';
        }, 2000);
        break;
      case 'local':
        dot.className = 'save-dot local';
        text.textContent = 'Saved locally';
        break;
      case 'pending':
        dot.className = 'save-dot pending';
        text.textContent = 'Changes pending...';
        break;
      default:
        dot.className = 'save-dot';
        text.textContent = 'Auto-save: On';
    }
  },
  
  /**
   * Logout function - redirects to login page
   */
  logout() {
    if (confirm('Are you sure you want to sign out?')) {
      // Use server-provided baseUrl as JavaScript variable
      const baseUrl = window.BASE_URL || 'https://script.google.com/macros/s/AKfycbwQJSoDlw_FMqikLTlwrYN6iD1_24sjsPajpC7_oqpSAuWXDvgOTJdR74evLF0bRsbd/exec';
      
      // Navigate to login page
      window.top.location.href = baseUrl + '?route=login';
    }
  },
  
  /**
   * Check if form has meaningful data (not just empty fields)
   */
  hasFormData(data) {
    if (!data || typeof data !== 'object') return false;
    
    // Check if any field has non-empty, meaningful content
    const meaningfulFields = Object.entries(data).filter(([key, value]) => {
      // Skip empty, null, undefined values
      if (!value || value === '' || value === null || value === undefined) return false;
      
      // Skip default/placeholder values that indicate no real input
      if (value === 'Select option' || value === 'Choose...' || value === '0') return false;
      
      // Skip fields that are just numbers representing no selection
      if (typeof value === 'string' && value.trim() === '') return false;
      
      return true;
    });
    
    console.log('Form data check:', { totalFields: Object.keys(data).length, meaningfulFields: meaningfulFields.length });
    return meaningfulFields.length > 0;
  },
  
  /**
   * Navigate back to dashboard with confirmation
   */
  backToDashboard() {
    // Check for unsaved changes
    const hasUnsavedChanges = this.checkUnsavedChanges();
    
    // Get current URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    // Check multiple possible session sources
    const sessionParam = urlParams.get('session') || 
                        (typeof sessionId !== 'undefined' ? sessionId : '') || 
                        '';
    const clientParam = urlParams.get('client') || 
                       (typeof userId !== 'undefined' ? userId : '') || 
                       'TEST001';
    
    // Use server-provided baseUrl as JavaScript variable
    const baseUrl = window.BASE_URL || 'https://script.google.com/macros/s/AKfycbw0NByXsEh7tszOE29ks25ZQlF0TPAtvuY9OCkrqVbyqyYOXkwnqKprTtmIZRpO1w06/exec';
    
    console.log('Dashboard navigation - using base URL:', baseUrl);
    
    // Create or update hidden form for navigation
    let navForm = document.getElementById('dashboard-nav-form');
    if (!navForm) {
      navForm = document.createElement('form');
      navForm.id = 'dashboard-nav-form';
      navForm.method = 'GET';
      navForm.action = baseUrl;
      navForm.target = '_top';
      navForm.style.display = 'none';
      navForm.innerHTML = `
        <input type="hidden" name="route" value="dashboard">
        <input type="hidden" name="client" id="nav-client" value="">
        <input type="hidden" name="session" id="nav-session" value="">
      `;
      document.body.appendChild(navForm);
    } else {
      navForm.action = baseUrl;
    }
    
    // Update form values
    document.getElementById('nav-client').value = clientParam;
    document.getElementById('nav-session').value = sessionParam;
    
    if (!sessionParam) {
      console.warn('No session found - dashboard may redirect to login');
    }
    
    // Helper function to navigate using form submission
    const navigateToDashboard = () => {
      console.log('Navigating to dashboard using form submission');
      console.log('Client:', clientParam, 'Session:', sessionParam);
      navForm.submit();
    };
    
    if (hasUnsavedChanges) {
      if (confirm('You have unsaved changes. Do you want to save before leaving?')) {
        this.saveDraft(false);
        setTimeout(() => {
          navigateToDashboard();
        }, 1000);
      } else if (confirm('Leave without saving? Your progress will be lost.')) {
        navigateToDashboard();
      }
    } else {
      navigateToDashboard();
    }
  },
  
  /**
   * Print current tool
   */
  printTool() {
    window.print();
  },
  
  /**
   * Export tool data
   */
  exportData() {
    const data = this.collectToolData(this.currentPattern);
    const exportData = {
      tool: this.currentTool,
      timestamp: new Date().toISOString(),
      data: data,
      progress: this.calculateProgress(this.currentPattern)
    };
    
    // Create download link
    const dataStr = JSON.stringify(exportData, null, 2);
    const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
    
    const exportName = `${this.currentTool}_${new Date().toISOString().split('T')[0]}.json`;
    
    const linkElement = document.createElement('a');
    linkElement.setAttribute('href', dataUri);
    linkElement.setAttribute('download', exportName);
    linkElement.click();
    
    this.showNotification('Data exported successfully', 'success');
  },
  
  /**
   * Show help for current tool
   */
  showHelp() {
    const helpContent = this.getToolHelp(this.currentTool);
    this.showModal('Help', helpContent);
  },
  
  /**
   * Show insights from other tools
   */
  showInsights() {
    if (typeof google !== 'undefined' && google.script && google.script.run) {
      google.script.run
        .withSuccessHandler((insights) => {
          const insightHtml = this.formatInsights(insights);
          this.showModal('Insights from Previous Tools', insightHtml);
        })
        .withFailureHandler(() => {
          this.showNotification('Unable to load insights', 'error');
        })
        .getRelevantInsights(userId, this.currentTool);
    }
  },
  
  /**
   * Show notification to user
   */
  showNotification(message, type = 'info') {
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.innerHTML = `
      <div class="notification-content">
        ${this.getNotificationIcon(type)}
        <span>${message}</span>
      </div>
    `;
    
    // Add to page
    document.body.appendChild(notification);
    
    // Animate in
    setTimeout(() => {
      notification.classList.add('show');
    }, 10);
    
    // Remove after 3 seconds
    setTimeout(() => {
      notification.classList.remove('show');
      setTimeout(() => {
        notification.remove();
      }, 300);
    }, 3000);
  },
  
  /**
   * Get notification icon by type
   */
  getNotificationIcon(type) {
    const icons = {
      'success': '‚úÖ',
      'error': '‚ùå',
      'warning': '‚ö†Ô∏è',
      'info': '‚ÑπÔ∏è'
    };
    return icons[type] || icons.info;
  },
  
  /**
   * Show modal dialog
   */
  showModal(title, content) {
    const modal = document.createElement('div');
    modal.className = 'tool-modal';
    modal.innerHTML = `
      <div class="modal-backdrop" onclick="ToolWrapper.closeModal()"></div>
      <div class="modal-content">
        <div class="modal-header">
          <h2>${title}</h2>
          <button onclick="ToolWrapper.closeModal()" class="modal-close">‚úï</button>
        </div>
        <div class="modal-body">
          ${content}
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    setTimeout(() => {
      modal.classList.add('show');
    }, 10);
  },
  
  /**
   * Close modal
   */
  closeModal() {
    const modal = document.querySelector('.tool-modal');
    if (modal) {
      modal.classList.remove('show');
      setTimeout(() => {
        modal.remove();
      }, 300);
    }
  },
  
  /**
   * Check for unsaved changes
   */
  checkUnsavedChanges() {
    // Ensure we have necessary data
    if (!this.currentTool) return false;
    
    // Compare current state with last saved state
    const pattern = this.currentPattern || 'pattern1';
    const currentData = JSON.stringify(this.collectToolData(pattern));
    const localKey = `draft_${this.currentTool}_${typeof userId !== 'undefined' ? userId : 'default'}`;
    const savedDraft = (typeof localStorage !== 'undefined' && localStorage) ? localStorage.getItem(localKey) : null;
    
    if (savedDraft) {
      const savedData = JSON.parse(savedDraft).data;
      return currentData !== JSON.stringify(savedData);
    }
    
    // Check if any fields have been filled
    const filledFields = document.querySelectorAll('#tool-content input:valid, #tool-content select:valid, #tool-content textarea:valid');
    return filledFields.length > 0;
  },
  
  /**
   * Update progress display with DOM safety checks
   */
  updateProgressDisplay(progress) {
    if (progress === null || progress === undefined) return;
    
    // Handle both number and object formats
    const progressValue = typeof progress === 'number' ? progress : 
                         (progress.percentage !== undefined ? progress.percentage : 0);
    
    const fillElement = document.getElementById('progress-fill');
    const percentElement = document.getElementById('progress-percent');
    const sectionElement = document.getElementById('progress-section');
    const stepsElement = document.getElementById('progress-steps');
    
    if (fillElement) {
      fillElement.style.width = `${Math.max(0, Math.min(100, progressValue))}%`;
    }
    if (percentElement) {
      percentElement.textContent = `${progressValue}% Complete`;
    }
    if (sectionElement && typeof progress === 'object' && progress.section) {
      sectionElement.textContent = progress.section;
    }
    if (stepsElement && typeof progress === 'object' && progress.currentStep && progress.totalSteps) {
      stepsElement.textContent = `Section ${progress.currentStep} of ${progress.totalSteps}`;
    }
  },
  
  /**
   * Show load options dialog
   */
  showLoadOptions() {
    const localKey = `draft_${this.currentTool}_${typeof userId !== 'undefined' ? userId : 'default'}`;
    const localDraft = (typeof localStorage !== 'undefined' && localStorage) ? localStorage.getItem(localKey) : null;
    
    let options = '<div class="load-options">';
    
    if (localDraft) {
      const draft = JSON.parse(localDraft);
      const date = new Date(draft.timestamp);
      options += `
        <div class="load-option">
          <h3>üì± Local Draft</h3>
          <p>Saved: ${date.toLocaleString()}</p>
          <p>Progress: ${typeof draft.progress === 'object' ? draft.progress.percentage : draft.progress || 0}%</p>
          <button onclick="ToolWrapper.loadDraft(); ToolWrapper.closeModal();" class="btn-primary">
            Load Local Draft
          </button>
        </div>
      `;
    }
    
    // Check for all server draft versions (up to 3)
    if (typeof google !== 'undefined' && google.script && google.script.run) {
      google.script.run
        .withSuccessHandler((draftsData) => {
          if (draftsData && draftsData.versions && draftsData.versions.length > 0) {
            let serverOptions = '<h3>‚òÅÔ∏è Cloud Drafts (Saved to Server)</h3>';
            
            draftsData.versions.forEach((draft, index) => {
              // Extract progress from the draft data
              const progressVal = draft.data && draft.data.progress ? 
                (typeof draft.data.progress === 'object' ? draft.data.progress.percentage : draft.data.progress) : 0;
              const versionLabel = index === 0 ? 'Latest' : `Version ${draftsData.versions.length - index}`;
              const timeDiff = Date.now() - new Date(draft.timestamp);
              const hoursAgo = Math.round(timeDiff / 3600000);
              
              serverOptions += `
                <div class="load-option" style="margin-top: 15px; padding: 15px; border: 1px solid var(--border); border-radius: 8px;">
                  <h4 style="color: var(--gold);">üìÑ ${versionLabel}</h4>
                  <p>Saved: ${new Date(draft.timestamp).toLocaleString()}</p>
                  <p>Progress: ${progressVal}% complete</p>
                  <p style="color: var(--muted); font-size: 12px;">${hoursAgo}h ago</p>
                  <button onclick="ToolWrapper.loadServerDraft('${draft.id}', '${userId}', '${this.currentTool}'); ToolWrapper.closeModal();" class="btn-primary">
                    Load ${versionLabel}
                  </button>
                </div>
              `;
            });
            
            const container = document.querySelector('.load-options');
            if (container) {
              container.innerHTML += serverOptions;
            }
          }
        })
        .withFailureHandler((error) => {
          console.error('Failed to get draft versions:', error);
        })
        .getAllDraftVersions(userId, this.currentTool);
    }
    
    options += '</div>';
    this.showModal('Load Previous Work', options);
  },
  
  /**
   * Load draft from server
   */
  loadServerDraft(draftId, userId, toolId) {
    if (typeof google !== 'undefined' && google.script && google.script.run) {
      google.script.run
        .withSuccessHandler((draft) => {
          if (draft && draft.data) {
            this.restoreToolState(draft);
            this.showNotification('Cloud draft loaded successfully', 'success');
            // Update progress display
            if (draft.data.progress) {
              this.updateProgressDisplay(draft.data.progress);
            }
            // Navigate to form after loading from landing page
            if (typeof startTool1Form === 'function') {
              setTimeout(() => {
                startTool1Form();
              }, 1000); // Small delay to show the success message
            }
          } else {
            this.showNotification('Draft not found or invalid', 'error');
          }
        })
        .withFailureHandler((error) => {
          console.error('Failed to load draft:', error);
          this.showNotification('Failed to load cloud draft', 'error');
        })
        .getSpecificDraft(draftId, userId, toolId);
    }
  },
  
  /**
   * Get help content for tool
   */
  getToolHelp(toolId) {
    const helps = {
      'tool1': `
        <h3>How to Complete the Orientation Assessment</h3>
        <ul>
          <li>Answer all questions honestly - there are no wrong answers</li>
          <li>Your progress is saved automatically every 2 minutes</li>
          <li>You can leave and come back anytime using the Load button</li>
          <li>The assessment takes about 20 minutes to complete</li>
          <li>Your Financial Health Score will be calculated at the end</li>
        </ul>
      `,
      'tool2': `
        <h3>Financial Clarity Assessment Help</h3>
        <p>This tool builds on your Orientation Assessment results...</p>
      `
      // Add more tool helps as needed
    };
    
    return helps[toolId] || '<p>Help content for this tool is being developed.</p>';
  },
  
  /**
   * Format insights for display
   */
  formatInsights(insights) {
    if (!insights || insights.length === 0) {
      return '<p>No insights available yet. Complete more tools to see cross-tool insights.</p>';
    }
    
    let html = '<div class="insights-list">';
    insights.forEach(insight => {
      html += `
        <div class="insight-item">
          <div class="insight-icon">${insight.icon || 'üí°'}</div>
          <div class="insight-content">
            <h4>${insight.title}</h4>
            <p>${insight.description}</p>
            <small>From: ${insight.source}</small>
          </div>
        </div>
      `;
    });
    html += '</div>';
    
    return html;
  },
  
  /**
   * Get calculator state for Pattern 4 tools
   */
  getCalculatorState() {
    // Tool-specific calculator state collection
    // Override this for each calculator tool
    return {};
  },
  
  /**
   * Restore calculator state for Pattern 4 tools
   */
  restoreCalculatorState(state) {
    // Tool-specific calculator state restoration
    // Override this for each calculator tool
  },
  
  /**
   * Get section-based progress
   */
  getSectionProgress() {
    // Calculate based on current section visibility
    // This would be customized per tool
    const sections = document.querySelectorAll('.form-section');
    const currentSection = document.querySelector('.form-section.active');
    
    if (sections.length > 0 && currentSection) {
      const currentIndex = Array.from(sections).indexOf(currentSection) + 1;
      const percentage = Math.round((currentIndex / sections.length) * 100);
      
      return {
        percentage,
        currentStep: currentIndex,
        totalSteps: sections.length,
        section: currentSection.dataset.sectionName || `Section ${currentIndex}`
      };
    }
    
    return {
      percentage: 0,
      currentStep: 1,
      totalSteps: 1,
      section: 'Getting Started'
    };
  }
};

// Make ToolWrapper globally available for Google Apps Script
if (typeof window !== 'undefined') {
  window.ToolWrapper = ToolWrapper;
}
</script>